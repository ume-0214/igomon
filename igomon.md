# å›²ç¢ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆã‚µã‚¤ãƒˆã€Œã„ã”ã‚‚ã‚“ã€ä»•æ§˜æ›¸

## 1. ã‚µã‚¤ãƒˆã‚³ãƒ³ã‚»ãƒ—ãƒˆ

åºç›¤ã‚„ä¸­ç›¤ãªã©ã€æ‰‹ã®é¸æŠè‚¢ãŒåºƒã„å±€é¢ã«ãŠã„ã¦ã€ã€Œãªãœãã“ã«æ‰“ã¡ãŸã„ã®ã‹ã€ã¨ã„ã†ã€ç€æ‰‹ã®ç†ç”±ã€ã‚’é›†ã‚ã‚‹ã“ã¨ã‚’ç›®çš„ã¨ã—ãŸã‚¢ãƒ³ã‚±ãƒ¼ãƒˆã‚µã‚¤ãƒˆã§ã‚ã‚‹ã€‚

å¤šãã®äººã®æ„è¦‹ã‚’é›†ã‚ã‚‹ãŸã‚ã€åŸå‰‡ã¨ã—ã¦å›ç­”è€…ã®ã¿ãŒä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å›ç­”çµæœã‚’é–²è¦§ã§ãã‚‹å½¢å¼ã¨ã™ã‚‹ã€‚

ç´šä½è€…ã‹ã‚‰é«˜æ®µè€…ã¾ã§ã€å¹…åºƒã„æ£‹åŠ›å±¤ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ°—è»½ã«å‚åŠ ã§ãã‚‹ã‚ˆã†ã€ã‚·ãƒ³ãƒ—ãƒ«ã§ä½¿ã„ã‚„ã™ã„ã‚·ã‚¹ãƒ†ãƒ ã‚’ç›®æŒ‡ã™ã€‚

## 2. æ©Ÿèƒ½è¦ä»¶

### 2.1. ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆå›ç­”ãƒšãƒ¼ã‚¸ (/questionnaire/{problem_id})

å„å•é¡Œã”ã¨ã«ã€ä¸€æ„ã®URLã‚’æŒã¤ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆå›ç­”ãƒšãƒ¼ã‚¸ã‚’ç”Ÿæˆã™ã‚‹ [user request]ã€‚

ãƒšãƒ¼ã‚¸ã«ã¯ã€SGFãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã‚“ã å•é¡Œã®ç›¤é¢ãŒè¡¨ç¤ºã•ã‚Œã‚‹ [user request]ã€‚è¡¨ç¤ºã™ã‚‹æ‰‹æ•°ã¯ã€description.txtã®movesãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§æŒ‡å®šã•ã‚ŒãŸæ‰‹æ•°ã¾ã§ï¼ˆæŒ‡å®šãŒãªã„å ´åˆã¯æœ€çµ‚æ‰‹ã¾ã§ï¼‰ã¨ã™ã‚‹ã€‚

ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ç›¤é¢ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã“ã¨ã§ç€æ‰‹ç‚¹ã‚’é¸æŠã§ãã€é¸æŠã—ãŸåº§æ¨™ã¯ãƒ•ã‚©ãƒ¼ãƒ ã«è‡ªå‹•å…¥åŠ›ã•ã‚Œã‚‹ã€‚åº§æ¨™ã¯UIä¸Šã§ã¯æ¨™æº–å›²ç¢è¨˜æ³•ï¼ˆA1ã€œT19ï¼‰ã§è¡¨ç¤ºã•ã‚Œã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ã¯SGFå½¢å¼ï¼ˆaa, ab, ac...ï¼‰ã§ä¿å­˜ã•ã‚Œã‚‹ã€‚

ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ç€æ‰‹ã‚’é¸æŠã—ã€ã€Œç€æ‰‹ã®ç†ç”±ã€ã€Œåå‰ã€ã€Œæ®µä½ã€ã‚’å…¥åŠ›ã—ã¦å›ç­”ã‚’é€ä¿¡ã™ã‚‹ã€‚

ã€Œåå‰ã€ã¨ã€Œæ®µä½ã€ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ã•ã‚Œã€æ¬¡å›ä»¥é™ã®å›ç­”æ™‚ã«ã¯è‡ªå‹•ã§å…¥åŠ›æ¬„ã«ã‚»ãƒƒãƒˆã•ã‚Œã‚‹ï¼ˆä»£æ¡ˆã®æ¡ç”¨ï¼‰ [user request]ã€‚

### 2.2. ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆçµæœè¡¨ç¤ºãƒšãƒ¼ã‚¸

ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¢ãƒ³ã‚±ãƒ¼ãƒˆã«å›ç­”ã‚’é€ä¿¡ã™ã‚‹ã¨ã€ãã®å•é¡Œã®çµæœè¡¨ç¤ºãƒšãƒ¼ã‚¸ã¸é·ç§»ã™ã‚‹ã€‚

çµæœãƒšãƒ¼ã‚¸ã§ã¯ã€ç›¤é¢ä¸Šã«å„ç€æ‰‹ã®å¾—ç¥¨æ•°ãŒæ•°å­—ã§è¡¨ç¤ºã•ã‚Œã‚‹ã€‚

å¾—ç¥¨æ•°ã«å¿œã˜ã¦æ•°å­—ã®èƒŒæ™¯è‰²ã‚„æ–‡å­—è‰²ã‚’å¤‰ãˆã‚‹ã“ã¨ã§ã€äººæ°—åº¦ã‚’è¦–è¦šçš„ã«åˆ†ã‹ã‚Šã‚„ã™ãè¡¨ç¤ºã™ã‚‹ï¼ˆä¾‹ï¼šå¾—ç¥¨æ•°10ä»¥ä¸Šã¯èµ¤è‰²ã€5-9ç¥¨ã¯æ©™è‰²ã€1-4ç¥¨ã¯é’è‰²ãªã©ï¼‰ã€‚

ç›¤é¢ã®æ•°å­—ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€ãã®åº§æ¨™ã«æŠ•ç¥¨ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å›ç­”ï¼ˆåå‰ã€æ®µä½ã€ç†ç”±ï¼‰ã®ä¸€è¦§ãŒå³å´ãªã©ã«è¡¨ç¤ºã•ã‚Œã‚‹ã€‚åº§æ¨™è¡¨ç¤ºã¯æ¨™æº–å›²ç¢è¨˜æ³•ï¼ˆA1ã€œT19ï¼‰ã‚’ä½¿ç”¨ã™ã‚‹ã€‚

### 2.3. æŠ•ç¨¿å‰Šé™¤æ©Ÿèƒ½

ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªåˆ†ãŒæŠ•ç¨¿ã—ãŸå›ç­”ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

å‰Šé™¤æ©Ÿèƒ½ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ–ãƒ©ã‚¦ã‚¶ã®Cookieã¾ãŸã¯ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ã•ã‚ŒãŸè­˜åˆ¥æƒ…å ±ã‚’ç”¨ã„ã¦ã€è‡ªåˆ†ã®æŠ•ç¨¿ã®ã¿ã‚’å‰Šé™¤å¯¾è±¡ã¨ã™ã‚‹ã€‚

å‰Šé™¤ã•ã‚ŒãŸå›ç­”ã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰å®Œå…¨ã«å‰Šé™¤ã•ã‚Œã‚‹ã‹ã€å‰Šé™¤ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã—ã¦éè¡¨ç¤ºã«ã™ã‚‹ã€‚

å‰Šé™¤å¾Œã¯ã€è©²å½“ã™ã‚‹ç€æ‰‹ã®å¾—ç¥¨æ•°ãŒæ¸›ç®—ã•ã‚Œã€çµæœè¡¨ç¤ºãƒšãƒ¼ã‚¸ã«å³åº§ã«åæ˜ ã•ã‚Œã‚‹ã€‚

å‰Šé™¤æ©Ÿèƒ½ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯ã€çµæœè¡¨ç¤ºãƒšãƒ¼ã‚¸ã®å›ç­”ä¸€è¦§ã«ãŠã„ã¦ã€è‡ªåˆ†ã®æŠ•ç¨¿ã«ã®ã¿ã€Œå‰Šé™¤ã€ãƒœã‚¿ãƒ³ãŒè¡¨ç¤ºã•ã‚Œã‚‹å½¢å¼ã¨ã™ã‚‹ã€‚

### 2.4. ã‚µã‚¤ãƒˆãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ (/)

ã‚µã‚¤ãƒˆã®ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ (https://igomon.net/) ã§ã¯ã€ä½œæˆã•ã‚ŒãŸå•é¡Œã®ä¸€è¦§ãŒè¡¨ç¤ºã•ã‚Œã‚‹ [user request]ã€‚

å•é¡Œã¯description.txtã«è¨˜è¼‰ã•ã‚ŒãŸcreatedã®æ—¥ä»˜ã‚’å…ƒã«ã€æ–°ã—ã„ã‚‚ã®ãŒä¸Šã«è¡¨ç¤ºã•ã‚Œã‚‹ï¼ˆä½œæˆæ—¥æ™‚ã®æ–°ã—ã„é †ï¼‰ [user request]ã€‚

ä¸€è¦§ã«ã¯ã€å•é¡Œã®ç›¤é¢ã‚µãƒ ãƒã‚¤ãƒ«ã€å•é¡Œç•ªå·ã€æ‰‹ç•ªãªã©ã®æƒ…å ±ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã“ã¨ãŒæœ›ã¾ã—ã„ã€‚

## 3. éæ©Ÿèƒ½è¦ä»¶

### 3.1. ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ã¨è­˜åˆ¥

Google/Xãªã©ã®SNSãƒ­ã‚°ã‚¤ãƒ³æ©Ÿèƒ½ã¯ä½¿ç”¨ã—ãªã„ [user request]ã€‚

ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è­˜åˆ¥ã¨ã€Œå›ç­”æ¸ˆã¿ã‹å¦ã‹ã€ã®åˆ¤å®šã¯ã€ãƒ–ãƒ©ã‚¦ã‚¶ã®Cookieã¾ãŸã¯ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’ç”¨ã„ã¦è¡Œã† [user request]ã€‚

ã“ã‚Œã«ã‚ˆã‚Šã€åŒä¸€ãƒ–ãƒ©ã‚¦ã‚¶ã§ã‚ã‚Œã°ã€ä¸€åº¦å›ç­”ã—ãŸå•é¡Œã®çµæœã¯é–²è¦§ã§ãã‚‹ãŒã€Cookieã‚’å‰Šé™¤ã—ãŸã‚Šã€åˆ¥ãƒ–ãƒ©ã‚¦ã‚¶ã§ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸå ´åˆã¯æœªå›ç­”ã®çŠ¶æ…‹ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ã€‚

### 3.2. ãƒ‡ãƒ¼ã‚¿æ°¸ç¶šåŒ–

ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰é€ä¿¡ã•ã‚ŒãŸã‚¢ãƒ³ã‚±ãƒ¼ãƒˆå›ç­”ï¼ˆç€æ‰‹åº§æ¨™ã€ç†ç”±ã€åå‰ã€æ®µä½ï¼‰ã¯ã€ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã® **SQLite ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹**ã«ä¿å­˜ã™ã‚‹ã€‚

**ORãƒãƒƒãƒ‘ãƒ¼:** Prisma ã‚’ä½¿ç”¨ï¼ˆå‹å®‰å…¨æ€§ã€ã‚¹ã‚­ãƒ¼ãƒç®¡ç†ã€ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã®ãŸã‚ï¼‰

SQLiteã‚’é¸æŠã™ã‚‹ç†ç”±ï¼š
- XServerã®å…±æœ‰ã‚µãƒ¼ãƒãƒ¼ç’°å¢ƒã«é©ã—ã¦ã„ã‚‹
- ãƒ•ã‚¡ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹ã§ç®¡ç†ãŒç°¡å˜
- ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¯å˜ç´”ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚³ãƒ”ãƒ¼
- äºˆæƒ³ã•ã‚Œã‚‹è² è·ï¼ˆæ•°åã®åŒæ™‚ã‚¢ã‚¯ã‚»ã‚¹ã€æ•°åƒã®å›ç­”ãƒ‡ãƒ¼ã‚¿ï¼‰ã«ååˆ†å¯¾å¿œå¯èƒ½

ãƒ¦ãƒ¼ã‚¶ãƒ¼åˆ©ä¾¿æ€§ã®ãŸã‚ã®ã€Œåå‰ã€ã€Œæ®µä½ã€ã®æƒ…å ±ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ã™ã‚‹ [user request]ã€‚

### 3.3. URLè¨­è¨ˆã¨OGP

**ã‚µã‚¤ãƒˆURL:** https://igomon.net/ [user request]

**å•é¡Œãƒšãƒ¼ã‚¸URL:** /questionnaire/{problem_id} ã®å½¢å¼ï¼ˆä¾‹: /questionnaire/1ï¼‰ [user request]

å•é¡Œãƒšãƒ¼ã‚¸ã®URLã¯ã€X (æ—§Twitter) ãªã©ã§å…±æœ‰ã•ã‚ŒãŸéš›ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹å¿…è¦ãŒã‚ã‚‹ [user request]ã€‚

Xã§å…±æœ‰ã•ã‚ŒãŸéš›ã«åˆ†ã‹ã‚Šã‚„ã™ã„ã‚«ãƒ¼ãƒ‰ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã€OGP (Open Graph Protocol) ã‚’è¨­å®šã™ã‚‹ã€‚

- **OGPç”»åƒ:** å•é¡Œã®ç›¤é¢ç”»åƒï¼ˆ1200x630pxã€Twitteræ¨å¥¨ã‚µã‚¤ã‚ºï¼‰
- **OGPã‚¿ã‚¤ãƒˆãƒ«:** å•é¡Œç•ªå·ã‚„æ‰‹ç•ªãªã©ã®ã‚¿ã‚¤ãƒˆãƒ«
- **OGPèª¬æ˜æ–‡:** å•é¡Œã®èª¬æ˜æ–‡
- **OGPç”»åƒç”Ÿæˆ:** problems/ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«æ–°è¦é…ç½®ã•ã‚ŒãŸæ™‚ã«è‡ªå‹•ç”Ÿæˆ

## 4. ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç®¡ç†

### 4.1. å•é¡Œã®ä½œæˆæ–¹æ³•

å•é¡Œã¯ã€ã‚µãƒ¼ãƒãƒ¼ã® `public/problems` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã€å•é¡Œã”ã¨ã®ã‚µãƒ–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’é…ç½®ã™ã‚‹ã“ã¨ã§ç”Ÿæˆã•ã‚Œã‚‹ [user request]ã€‚

å„å•é¡Œã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã¯ã€ç›¤é¢ãƒ‡ãƒ¼ã‚¿ã§ã‚ã‚‹`kifu.sgf`ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã€å•é¡Œæƒ…å ±ã‚’è¨˜è¿°ã—ãŸ`description.txt`ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é…ç½®ã™ã‚‹ [user request]ã€‚

**ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ä¾‹:**

```
igomon-app/
â”œâ”€â”€ public/
â”‚   â””â”€â”€ problems/
â”‚       â”œâ”€â”€ 1/
â”‚       â”‚   â”œâ”€â”€ kifu.sgf
â”‚       â”‚   â””â”€â”€ description.txt
â”‚       â”œâ”€â”€ 2/
â”‚       â”‚   â”œâ”€â”€ kifu.sgf
â”‚       â”‚   â””â”€â”€ description.txt
â”‚       â””â”€â”€ 1515/
â”‚           â”œâ”€â”€ kifu.sgf
â”‚           â””â”€â”€ description.txt
```

### 4.2. description.txt ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

`description.txt`ã¯ã€ä»¥ä¸‹ã®ã€Œã‚­ãƒ¼: å€¤ã€å½¢å¼ã§è¨˜è¿°ã™ã‚‹ï¼ˆææ¡ˆã®æ¡ç”¨ï¼‰ [user request]ã€‚

```plaintext
id: 1515
turn: black
created: 2025-06-27
moves: 30
description: ç€æ‰‹ã¨ãã®ç†ç”±ã‚’å›ç­”ã—ã¦ãã ã•ã„ã€‚
```

- **id:** (å¿…é ˆ) ãƒšãƒ¼ã‚¸ã«è¡¨ç¤ºã•ã‚Œã‚‹å•é¡Œç•ªå·ã€‚
- **turn:** (å¿…é ˆ) æ‰‹ç•ªã€‚black ã¾ãŸã¯ white ã§æŒ‡å®šã€‚
- **created:** (å¿…é ˆ) å•é¡Œã®ä½œæˆæ—¥ã€‚ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ã§ã®ä¸¦ã³æ›¿ãˆã«ä½¿ç”¨ã€‚
- **moves:** (ä»»æ„) è¡¨ç¤ºã™ã‚‹æ‰‹æ•°ã€‚æŒ‡å®šãŒãªã„å ´åˆã¯æœ€çµ‚æ‰‹ã¾ã§è¡¨ç¤ºã€‚
- **description:** (å¿…é ˆ) ç›¤ã®ä¸‹ã«è¡¨ç¤ºã•ã‚Œã‚‹èª¬æ˜æ–‡ã€‚

## 5. UIã‚¤ãƒ¡ãƒ¼ã‚¸

### ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆå›ç­”ãƒšãƒ¼ã‚¸ã®ã‚¤ãƒ¡ãƒ¼ã‚¸
![ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆå›ç­”ãƒšãƒ¼ã‚¸](docs/png/ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆå›ç­”ãƒšãƒ¼ã‚¸ã‚¤ãƒ¡ãƒ¼ã‚¸.png)

### ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆçµæœè¡¨ç¤ºãƒšãƒ¼ã‚¸ã®ã‚¤ãƒ¡ãƒ¼ã‚¸
![ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆçµæœè¡¨ç¤ºãƒšãƒ¼ã‚¸](docs/png/ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆçµæœãƒšãƒ¼ã‚¸ã‚¤ãƒ¡ãƒ¼ã‚¸2.png)

### ã‚µã‚¤ãƒˆãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ã®ã‚¤ãƒ¡ãƒ¼ã‚¸
![ã‚µã‚¤ãƒˆãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸](docs/png/ã‚µã‚¤ãƒˆãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ã‚¤ãƒ¡ãƒ¼ã‚¸.png)

## 6. å®Ÿè£…å¯¾è±¡å¤–ï¼ˆé™¤å¤–æ©Ÿèƒ½ï¼‰

ä»¥ä¸‹ã®æ©Ÿèƒ½ã¯ã€ä»Šå›ã®å®Ÿè£…ç¯„å›²ã«å«ã¾ãªã„ã€‚

- Google/Xã‚¢ã‚«ã‚¦ãƒ³ãƒˆç­‰ã‚’åˆ©ç”¨ã—ãŸãƒ­ã‚°ã‚¤ãƒ³æ©Ÿèƒ½
- å›ç­”ã«å¯¾ã™ã‚‹ã€Œã„ã„ã­ã€ã€Œã‚ˆããªã„ã€ãƒœã‚¿ãƒ³
- ã‚µã‚¤ãƒˆãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ã®æ¤œç´¢æ©Ÿèƒ½ã€æœ€è¿‘ã®æŠ•ç¨¿ãƒ»ã‚³ãƒ¡ãƒ³ãƒˆæ¬„
- ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆçµæœã®CSVå½¢å¼ã§ã®ãƒ‡ãƒ¼ã‚¿åé›†æ©Ÿèƒ½ [user request]
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹å›ç­”ã®ç·¨é›†æ©Ÿèƒ½ï¼ˆå‰Šé™¤æ©Ÿèƒ½ã¯å®Ÿè£…å¯¾è±¡ï¼‰

## 7. æŠ€è¡“ä»•æ§˜è©³ç´°

### 7.1. ãƒ¦ãƒ¼ã‚¶ãƒ¼è­˜åˆ¥ã‚·ã‚¹ãƒ†ãƒ 

**ãƒ¦ãƒ¼ã‚¶ãƒ¼IDç”Ÿæˆ:**
- æŠ•ç¨¿æ™‚ã«UUIDï¼ˆv4ï¼‰ã‚’ç”Ÿæˆã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’è­˜åˆ¥
- UUIDã¯ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ï¼ˆæ¨å¥¨ï¼‰
- ã‚µãƒ¼ãƒãƒ¼å´ã§ã¯èªè¨¼ãªã—ã§ã€UUIDã®ä¸€è‡´ç¢ºèªã«ã‚ˆã‚ŠæŠ•ç¨¿è€…ã‚’ç‰¹å®š
- UUIDè¡çªå¯¾ç­–ã¨ã—ã¦ã€crypto.randomUUID()ã‚’ä½¿ç”¨ï¼ˆæš—å·å­¦çš„ã«å®‰å…¨ï¼‰

**å®Ÿè£…æ–¹é‡:**
```javascript
// åˆå›ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã¾ãŸã¯UUIDãŒå­˜åœ¨ã—ãªã„å ´åˆ
const userUuid = localStorage.getItem('igomon_user_uuid') || 
                crypto.randomUUID();
localStorage.setItem('igomon_user_uuid', userUuid);
```

### 7.2. å‰Šé™¤æ©Ÿèƒ½ã®å®Ÿè£…

**å‰Šé™¤æ–¹å¼:** è«–ç†å‰Šé™¤ï¼ˆç‰©ç†å‰Šé™¤ã¯è¡Œã‚ãªã„ï¼‰

**å‰Šé™¤ãƒ•ãƒ­ãƒ¼:**
1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè‡ªåˆ†ã®æŠ•ç¨¿ã®ã€Œå‰Šé™¤ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
2. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‹ã‚‰ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®UUIDã‚’å«ã‚€DELETEãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡
3. ã‚µãƒ¼ãƒãƒ¼å´ã§UUIDã®ä¸€è‡´ã‚’ç¢ºèª
4. `is_deleted`ãƒ•ãƒ©ã‚°ã‚’trueã«æ›´æ–°
5. å¾—ç¥¨æ•°ã‚’å†è¨ˆç®—ã—ã¦çµæœè¡¨ç¤ºã‚’æ›´æ–°

**å‰Šé™¤æ¨©é™:**
- çµæœè¡¨ç¤ºãƒšãƒ¼ã‚¸ã§è‡ªåˆ†ã®æŠ•ç¨¿ã®ã¿ã«ã€Œå‰Šé™¤ã€ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
- UUIDãŒä¸€è‡´ã™ã‚‹æŠ•ç¨¿ã®ã¿å‰Šé™¤å¯èƒ½

### 7.3. SGFãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†

**ä½¿ç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒª:** WGo.js
- SGFè§£æã€ç›¤é¢æç”»ã€åº§æ¨™å¤‰æ›ã‚’çµ±åˆã‚µãƒãƒ¼ãƒˆ
- Canvas/SVGä¸¡å¯¾å¿œã§ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–
- 19è·¯ç›¤ã®ã¿å¯¾å¿œ

**è¡¨ç¤ºä»•æ§˜:**
- SGFãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æŒ‡å®šæ‰‹æ•°ã¾ã§ï¼ˆã¾ãŸã¯description.txtã®movesãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¾ã§ï¼‰ã®å±€é¢ã‚’è¡¨ç¤º
- movesãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯æœ€çµ‚æ‰‹ã¾ã§è¡¨ç¤º
- ã‚³ãƒ¡ãƒ³ãƒˆã‚„ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ã¯ç„¡è¦–ã™ã‚‹
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ç›¤é¢ã‚¯ãƒªãƒƒã‚¯ã§ç€æ‰‹ç‚¹ã‚’é¸æŠ
- ã‚¯ãƒªãƒƒã‚¯åº§æ¨™ã¯è‡ªå‹•çš„ã«SGFå½¢å¼ã«å¤‰æ›ã—ã¦ãƒ•ã‚©ãƒ¼ãƒ ã«å…¥åŠ›

**åº§æ¨™ã‚·ã‚¹ãƒ†ãƒ :**
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¿å­˜: SGFåº§æ¨™ï¼ˆaa, ab, ac...ï¼‰
- å†…éƒ¨å‡¦ç†: æ•°å€¤åº§æ¨™ (0,0)ã€œ(18,18)
- UIè¡¨ç¤º: æ¨™æº–å›²ç¢è¨˜æ³•ï¼ˆA1ã€œT19ï¼‰
- WGo.jsã®åº§æ¨™å¤‰æ›æ©Ÿèƒ½ã‚’æ´»ç”¨

**åº§æ¨™ã®å¯¾å¿œé–¢ä¿‚:**
- A19 = WGo.js (0, 0) = SGF "aa"
- T19 = WGo.js (18, 0) = SGF "sa"
- A1 = WGo.js (0, 18) = SGF "as"
- T1 = WGo.js (18, 18) = SGF "ss"

### 7.4. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆï¼ˆPrisma + SQLiteï¼‰

**Prismaã‚¹ã‚­ãƒ¼ãƒ:**
```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./igomon.db"
}

model Problem {
  id          Int      @id
  sgfFilePath String   @map("sgf_file_path")
  description String
  turn        String   // "black" or "white"
  createdDate String   @map("created_date")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  answers     Answer[]

  @@map("problems")
}

model Answer {
  id          Int      @id @default(autoincrement())
  problemId   Int      @map("problem_id")
  userUuid    String   @map("user_uuid")
  coordinate  String   // SGFåº§æ¨™ (aa, ab, etc.)
  reason      String
  playerName  String   @map("player_name")
  playerRank  String   @map("player_rank")
  isDeleted   Boolean  @default(false) @map("is_deleted")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  problem     Problem  @relation(fields: [problemId], references: [id])

  @@index([problemId])
  @@index([userUuid])
  @@index([coordinate])
  @@index([isDeleted])
  @@map("answers")
}
```

### 7.5. çµæœè¡¨ç¤ºæ©Ÿèƒ½

**ç›¤é¢è¡¨ç¤º:**
- WGo.jsã‚’ä½¿ç”¨ã—ã¦ç›¤é¢ä¸Šã«å¾—ç¥¨æ•°ã‚’æ•°å­—ã§è¡¨ç¤º
- å¾—ç¥¨æ•°ã«å¿œã˜ãŸè‰²åˆ†ã‘ã‚„ã‚µã‚¤ã‚ºèª¿æ•´ãŒå¯èƒ½
- æ•°å­—ã‚¯ãƒªãƒƒã‚¯æ™‚ã«è©²å½“åº§æ¨™ã®å›ç­”ä¸€è¦§ã‚’è¡¨ç¤º

**å®Ÿè£…ä¾‹:**
```javascript
// çµæœãƒ‡ãƒ¼ã‚¿ã‚’ç›¤é¢ã«è¡¨ç¤º
results.forEach(result => {
    const coords = sgfToWgoCoords(result.coordinate);
    board.addObject({
        x: coords.x, y: coords.y,
        type: "mark",
        mark: {
            type: "label",
            text: result.votes.toString(),
            color: getColorByVotes(result.votes)
        }
    });
});

// åº§æ¨™å¤‰æ›é–¢æ•°
function sgfToWgoCoords(sgf) {
    const x = sgf.charCodeAt(0) - 'a'.charCodeAt(0);
    const y = sgf.charCodeAt(1) - 'a'.charCodeAt(0);
    return { x, y };
}

function wgoToSgfCoords(x, y) {
    return String.fromCharCode('a'.charCodeAt(0) + x) + 
           String.fromCharCode('a'.charCodeAt(0) + y);
}

function wgoToStandardNotation(x, y) {
    const letters = 'ABCDEFGHJKLMNOPQRST'; // Iã‚’é™¤ã
    return letters[x] + (19 - y);
}
```

### 7.6. OGPç”»åƒç”Ÿæˆ

**æ¨å¥¨æ–¹æ³•:** Node.js + Canvas

**å®Ÿè£…æˆ¦ç•¥:**
1. problems/ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ãŒé…ç½®ã•ã‚ŒãŸæ™‚ã«è‡ªå‹•å®Ÿè¡Œ
2. SGFãƒ•ã‚¡ã‚¤ãƒ«ã‚’è§£æã—ã¦ç›¤é¢çŠ¶æ…‹ã‚’å–å¾—ï¼ˆmovesãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¾ã§ï¼‰
3. Canvasã§19x19ã®ç¢ç›¤ã‚’æç”»
4. çŸ³ã‚’é…ç½®ã—ã¦1200x630pxã®PNGç”»åƒã¨ã—ã¦ç”Ÿæˆ
5. public/ogp/problem_{id}.png ã¨ã—ã¦ä¿å­˜
6. ç”»åƒã«ã‚¿ã‚¤ãƒˆãƒ«ã‚„å•é¡Œç•ªå·ã¯å«ã‚ãªã„ï¼ˆç›¤é¢ã®ã¿ï¼‰

**å®Ÿè£…ä¾‹:**
```javascript
const { createCanvas } = require('canvas');

function generateOgpImage(sgfContent, problemId) {
    const canvas = createCanvas(600, 600);
    const ctx = canvas.getContext('2d');
    
    // ç¢ç›¤ã‚’æç”»
    drawBoard(ctx);
    
    // SGFã‹ã‚‰çŸ³ã®é…ç½®ã‚’èª­ã¿è¾¼ã‚“ã§æç”»
    const stones = parseSgf(sgfContent);
    drawStones(ctx, stones);
    
    // PNGç”»åƒã¨ã—ã¦ä¿å­˜
    const buffer = canvas.toBuffer('image/png');
    fs.writeFileSync(`public/ogp/problem_${problemId}.png`, buffer);
}
```

### 7.7. APIè¨­è¨ˆ

**ä¸»è¦ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ:**

```
GET  /questionnaire/{problem_id}     # ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆå›ç­”ãƒšãƒ¼ã‚¸
POST /api/answers                    # å›ç­”æŠ•ç¨¿
GET  /api/results/{problem_id}       # çµæœå–å¾—
DELETE /api/answers/{answer_id}      # å›ç­”å‰Šé™¤ï¼ˆè«–ç†å‰Šé™¤ï¼‰
GET  /api/problems                   # å•é¡Œä¸€è¦§
GET  /api/sgf/{problem_id}          # SGFãƒ•ã‚¡ã‚¤ãƒ«å–å¾—
```

**æŠ•ç¨¿ãƒ‡ãƒ¼ã‚¿å½¢å¼:**
```json
{
    "problem_id": 1,
    "user_uuid": "550e8400-e29b-41d4-a716-446655440000",
    "coordinate": "dd",
    "reason": "ã“ã®æ‰‹ãŒæœ€ã‚‚åŠ¹ç‡çš„ã ã¨æ€ã„ã¾ã™",
    "player_name": "ç”°ä¸­å¤ªéƒ",
    "player_rank": "3æ®µ"
}
```

## 8. XServerå‘ã‘çµ±åˆæŠ€è¡“æ§‹æˆ

### 8.1. æ¨å¥¨æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

**ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯æ§‹æˆ:**
- **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰:** React + TypeScript
- **ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰:** Express.js + TypeScript
- **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹:** SQLite + Prisma
- **ç¢ç›¤è¡¨ç¤º:** WGo.js
- **OGPç”»åƒç”Ÿæˆ:** Node.js Canvas
- **ãƒ‡ãƒ—ãƒ­ã‚¤:** XServer Node.jsç’°å¢ƒ

### 8.2. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹æˆ

```
igomon-app/
â”œâ”€â”€ prisma/
â”‚   â”œâ”€â”€ schema.prisma              // Prismaã‚¹ã‚­ãƒ¼ãƒ
â”‚   â””â”€â”€ migrations/                // ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«
â”œâ”€â”€ server/
â”‚   â”œâ”€â”€ index.ts                   // Express.jsã‚µãƒ¼ãƒãƒ¼ï¼ˆPM2/foreverä¸è¦ï¼‰
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ api.ts                 // API ãƒ«ãƒ¼ãƒˆ
â”‚   â”‚   â”œâ”€â”€ answers.ts             // å›ç­”é–¢é€£API
â”‚   â”‚   â””â”€â”€ problems.ts            // å•é¡Œé–¢é€£API
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ sgf-parser.ts          // SGFå‡¦ç†ï¼ˆæ‰‹æ•°æŒ‡å®šå¯¾å¿œï¼‰
â”‚       â””â”€â”€ ogp-generator.ts       // OGPç”»åƒç”Ÿæˆ
â”œâ”€â”€ client/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ GoBoard.tsx        // WGo.jsç¢ç›¤ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”‚   â”‚   â”œâ”€â”€ AnswerForm.tsx     // å›ç­”ãƒ•ã‚©ãƒ¼ãƒ 
â”‚   â”‚   â”‚   â””â”€â”€ ResultsDisplay.tsx // çµæœè¡¨ç¤º
â”‚   â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”‚   â”œâ”€â”€ Home.tsx           // ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸
â”‚   â”‚   â”‚   â”œâ”€â”€ Questionnaire.tsx  // ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆãƒšãƒ¼ã‚¸
â”‚   â”‚   â”‚   â””â”€â”€ Results.tsx        // çµæœãƒšãƒ¼ã‚¸
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â”œâ”€â”€ api.ts             // APIå‘¼ã³å‡ºã—
â”‚   â”‚   â”‚   â””â”€â”€ uuid.ts            // UUIDç®¡ç†
â”‚   â”‚   â””â”€â”€ App.tsx
â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ problems/                  // SGFãƒ•ã‚¡ã‚¤ãƒ«
â”‚   â”œâ”€â”€ ogp/                      // ç”ŸæˆOGPç”»åƒ
â”‚   â””â”€â”€ dist/                     // ãƒ“ãƒ«ãƒ‰æ¸ˆã¿ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ database.ts               // Prisma Clientæ“ä½œ
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ igomon.db                     // SQLiteãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«
```

### 8.3. ä¾å­˜é–¢ä¿‚

```json
{
  "name": "igomon-app",
  "version": "1.0.0",
  "engines": {
    "node": "18.x"
  },
  "dependencies": {
    "chokidar": "^3.5.0",
    "cors": "^2.8.5",
    "express": "^4.18.0",
    "prisma": "^5.0.0",
    "@prisma/client": "^5.0.0",
    "socket.io": "^4.7.0",
    "socket.io-client": "^4.7.0",
    "wgo": "^2.3.1",
    "canvas": "^2.11.0",
    "uuid": "^9.0.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "react-router-dom": "^6.0.0",
    "typescript": "^5.0.0",
    "@types/chokidar": "^3.5.0",
    "@types/node": "^20.0.0",
    "@types/express": "^4.17.0",
    "@types/socket.io": "^3.0.0",
    "@types/uuid": "^9.0.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.0.0",
    "nodemon": "^3.0.0",
    "ts-node": "^10.0.0",
    "vite": "^4.0.0"
  },
  "scripts": {
    "dev:client": "vite",
    "dev:server": "nodemon --exec ts-node server/index.ts",
    "build:client": "vite build --outDir ../public/dist",
    "build:server": "tsc server/index.ts --outDir dist",
    "start": "node dist/server/index.js",
    "db:migrate": "prisma migrate dev",
    "db:generate": "prisma generate",
    "db:studio": "prisma studio"
  }
}
```

### 8.4. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œï¼ˆPrismaå®Ÿè£…ï¼‰

```typescript
// lib/database.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// å›ç­”ã®ä¿å­˜
export async function saveAnswer(answerData: {
  problemId: number;
  userUuid: string;
  coordinate: string;
  reason: string;
  playerName: string;
  playerRank: string;
}) {
  return await prisma.answer.create({
    data: answerData
  });
}

// çµæœã®å–å¾—
export async function getResults(problemId: number) {
  const answers = await prisma.answer.findMany({
    where: { 
      problemId: problemId, 
      isDeleted: false 
    },
    orderBy: { createdAt: 'asc' }
  });
  
  // åº§æ¨™ã”ã¨ã®é›†è¨ˆ
  const results: Record<string, { votes: number; answers: any[] }> = {};
  answers.forEach(answer => {
    if (!results[answer.coordinate]) {
      results[answer.coordinate] = { votes: 0, answers: [] };
    }
    results[answer.coordinate].votes++;
    results[answer.coordinate].answers.push(answer);
  });
  
  return results;
}

// å›ç­”ã®å‰Šé™¤ï¼ˆè«–ç†å‰Šé™¤ï¼‰
export async function deleteAnswer(answerId: number, userUuid: string) {
  const result = await prisma.answer.updateMany({
    where: { 
      id: answerId, 
      userUuid: userUuid,
      isDeleted: false 
    },
    data: { 
      isDeleted: true,
      updatedAt: new Date()
    }
  });
  
  return result.count > 0;
}

// å•é¡Œä¸€è¦§ã®å–å¾—
export async function getProblems() {
  return await prisma.problem.findMany({
    orderBy: { createdDate: 'desc' },
    include: {
      _count: {
        select: {
          answers: {
            where: { isDeleted: false }
          }
        }
      }
    }
  });
}

// å•é¡Œã®è©³ç´°å–å¾—
export async function getProblem(problemId: number) {
  return await prisma.problem.findUnique({
    where: { id: problemId }
  });
}

// å•é¡Œã®å­˜åœ¨ç¢ºèªï¼ˆIDé‡è¤‡ãƒã‚§ãƒƒã‚¯ç”¨ï¼‰
export async function problemExists(problemId: number) {
  const problem = await prisma.problem.findUnique({
    where: { id: problemId },
    select: { id: true }
  });
  return !!problem;
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ—¢ã«å›ç­”æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
export async function hasUserAnswered(problemId: number, userUuid: string) {
  const answer = await prisma.answer.findFirst({
    where: {
      problemId: problemId,
      userUuid: userUuid,
      isDeleted: false
    }
  });
  return !!answer;
}

export default prisma;
```

### 8.5. APIå®Ÿè£…ä¾‹ï¼ˆExpress.js + Prismaï¼‰

```typescript
// server/routes/api.ts
import express from 'express';
import { 
  saveAnswer, 
  getResults, 
  deleteAnswer, 
  getProblems,
  getProblem,
  hasUserAnswered 
} from '../lib/database';

const router = express.Router();

// å›ç­”æŠ•ç¨¿
router.post('/answers', async (req, res) => {
  try {
    const { problemId, userUuid, coordinate, reason, playerName, playerRank } = req.body;
    
    // æ—¢ã«å›ç­”æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
    const alreadyAnswered = await hasUserAnswered(problemId, userUuid);
    if (alreadyAnswered) {
      return res.status(400).json({ error: 'Already answered this problem' });
    }
    
    const result = await saveAnswer({
      problemId,
      userUuid,
      coordinate,
      reason,
      playerName,
      playerRank
    });
    
    res.json(result);
  } catch (error) {
    console.error('Error saving answer:', error);
    res.status(500).json({ error: 'Failed to save answer' });
  }
});

// çµæœå–å¾—
router.get('/results/:problemId', async (req, res) => {
  try {
    const problemId = parseInt(req.params.problemId);
    const results = await getResults(problemId);
    res.json(results);
  } catch (error) {
    console.error('Error getting results:', error);
    res.status(500).json({ error: 'Failed to get results' });
  }
});

// å›ç­”å‰Šé™¤
router.delete('/answers/:answerId', async (req, res) => {
  try {
    const answerId = parseInt(req.params.answerId);
    const { userUuid } = req.body;
    
    const success = await deleteAnswer(answerId, userUuid);
    
    if (success) {
      res.json({ success: true });
    } else {
      res.status(404).json({ error: 'Answer not found or not authorized' });
    }
  } catch (error) {
    console.error('Error deleting answer:', error);
    res.status(500).json({ error: 'Failed to delete answer' });
  }
});

// å•é¡Œä¸€è¦§å–å¾—
router.get('/problems', async (req, res) => {
  try {
    const problems = await getProblems();
    res.json(problems);
  } catch (error) {
    console.error('Error getting problems:', error);
    res.status(500).json({ error: 'Failed to get problems' });
  }
});

// å•é¡Œè©³ç´°å–å¾—
router.get('/problems/:problemId', async (req, res) => {
  try {
    const problemId = parseInt(req.params.problemId);
    const problem = await getProblem(problemId);
    
    if (!problem) {
      return res.status(404).json({ error: 'Problem not found' });
    }
    
    res.json(problem);
  } catch (error) {
    console.error('Error getting problem:', error);
    res.status(500).json({ error: 'Failed to get problem' });
  }
});

// SGFãƒ•ã‚¡ã‚¤ãƒ«å–å¾—
router.get('/sgf/:problemId', (req, res) => {
  try {
    const problemId = req.params.problemId;
    const problemData = loadProblemFromDirectory(problemId);
    
    if (!problemData) {
      return res.status(404).json({ error: 'Problem not found' });
    }
    
    res.setHeader('Content-Type', 'application/x-go-sgf');
    res.send(problemData.sgfContent);
  } catch (error) {
    console.error('Error getting SGF:', error);
    res.status(500).json({ error: 'Failed to get SGF' });
  }
});

// å•é¡Œä¸€è¦§å–å¾—ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹ + ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆï¼‰
router.get('/problems', async (req, res) => {
  try {
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰å•é¡Œä¸€è¦§ã‚’å–å¾—
    const fileProblems = getAllProblems();
    
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å›ç­”æ•°ã‚‚å«ã‚ã¦è¿”ã™
    const problemsWithCounts = await Promise.all(
      fileProblems.map(async (problem) => {
        const answerCount = await prisma.answer.count({
          where: {
            problemId: problem.id,
            isDeleted: false
          }
        });
        
        return {
          ...problem,
          answerCount
        };
      })
    );
    
    res.json(problemsWithCounts);
  } catch (error) {
    console.error('Error getting problems:', error);
    res.status(500).json({ error: 'Failed to get problems' });
  }
});
```

### 8.6. Expressã‚µãƒ¼ãƒãƒ¼è¨­å®š

```typescript
// server/index.ts
import express from 'express';
import { createServer } from 'http';
import { Server as SocketIOServer } from 'socket.io';
import cors from 'cors';
import path from 'path';
import apiRoutes from './routes/api';
import { ProblemWatcher } from './utils/file-watcher';
import { getAllProblems } from './utils/problem-loader';

const app = express();
const server = createServer(app);
const io = new SocketIOServer(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"]
  }
});

const port = process.env.PORT || 3000;

// ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// é™çš„ãƒ•ã‚¡ã‚¤ãƒ«é…ä¿¡
app.use(express.static(path.join(__dirname, '../public/dist')));
app.use('/problems', express.static(path.join(__dirname, '../public/problems')));
app.use('/ogp', express.static(path.join(__dirname, '../public/ogp')));

// API ãƒ«ãƒ¼ãƒˆ
app.use('/api', apiRoutes);

// WebSocketæ¥ç¶šå‡¦ç†
io.on('connection', (socket) => {
  console.log('Client connected:', socket.id);
  
  // æ¥ç¶šæ™‚ã«ç¾åœ¨ã®å•é¡Œä¸€è¦§ã‚’é€ä¿¡
  socket.emit('initialProblems', getAllProblems());
  
  socket.on('disconnect', () => {
    console.log('Client disconnected:', socket.id);
  });
});

// ãƒ•ã‚¡ã‚¤ãƒ«ç›£è¦–ã‚’é–‹å§‹
const problemWatcher = new ProblemWatcher(io);

// SPAç”¨ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '../public/dist/index.html'));
});

// ã‚µãƒ¼ãƒãƒ¼çµ‚äº†æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
process.on('SIGTERM', () => {
  problemWatcher.destroy();
  server.close();
});

server.listen(port, () => {
  console.log(`Server running on port ${port}`);
});
```

### 8.7. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å®Ÿè£…ä¾‹

```typescript
// client/src/utils/uuid.ts
export function getUserUuid(): string {
  let uuid = localStorage.getItem('igomon_user_uuid');
  if (!uuid) {
    uuid = crypto.randomUUID();
    localStorage.setItem('igomon_user_uuid', uuid);
  }
  return uuid;
}

// client/src/utils/api.ts
export async function submitAnswer(answerData: {
  problemId: number;
  coordinate: string;
  reason: string;
  playerName: string;
  playerRank: string;
}) {
  const userUuid = getUserUuid();
  
  const response = await fetch('/api/answers', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      ...answerData,
      userUuid
    }),
  });
  
  if (!response.ok) {
    throw new Error('Failed to submit answer');
  }
  
  return response.json();
}

export async function getResults(problemId: number) {
  const response = await fetch(`/api/results/${problemId}`);
  if (!response.ok) {
    throw new Error('Failed to get results');
  }
  return response.json();
}

export async function deleteAnswer(answerId: number) {
  const userUuid = getUserUuid();
  
  const response = await fetch(`/api/answers/${answerId}`, {
    method: 'DELETE',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ userUuid }),
  });
  
  if (!response.ok) {
    throw new Error('Failed to delete answer');
  }
  
  return response.json();
}
```

### 8.8. Prismaã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚³ãƒãƒ³ãƒ‰

```bash
# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆæœŸåŒ–
npm init -y

# ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
npm install

# Prismaã®åˆæœŸåŒ–ï¼ˆSQLiteç”¨ï¼‰
npx prisma init --datasource-provider sqlite

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
npx prisma migrate dev --name init

# Prisma Clientã®ç”Ÿæˆ
npx prisma generate

# é–‹ç™ºç”¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç¢ºèª
npx prisma studio

# é–‹ç™ºã‚µãƒ¼ãƒãƒ¼èµ·å‹•
npm run dev:client  # ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
npm run dev:server  # ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰
```

### 8.9. XServerãƒ‡ãƒ—ãƒ­ã‚¤æ‰‹é †

1. **ãƒ“ãƒ«ãƒ‰å®Ÿè¡Œ:**
```bash
npm run build:client  # React ã‚¢ãƒ—ãƒªã®ãƒ“ãƒ«ãƒ‰
npm run build:server  # TypeScript ã‚µãƒ¼ãƒãƒ¼ã®ãƒ“ãƒ«ãƒ‰
```

2. **ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰:**
- `public/dist/` â†’ XServer å…¬é–‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
- `dist/server/` â†’ Node.js ã‚¢ãƒ—ãƒªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
- `prisma/` â†’ Prisma è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
- `igomon.db` â†’ SQLite ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«

3. **XServer ã§ã®èµ·å‹•è¨­å®š:**
```javascript
// XServerç”¨ã®èµ·å‹•ãƒ•ã‚¡ã‚¤ãƒ«
const app = require('./dist/server/index.js');
```

ã“ã®æ§‹æˆã«ã‚ˆã‚Šã€XServerã®åˆ¶ç´„ä¸‹ã§ã‚‚Prismaã‚’ä½¿ç”¨ã—ãŸå‹å®‰å…¨ã§ä¿å®ˆã—ã‚„ã™ã„ã€Œã„ã”ã‚‚ã‚“ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰ã§ãã¾ã™ã€‚

### 8.10. å•é¡Œãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å‡¦ç†

```typescript
// server/utils/problem-loader.ts
import fs from 'fs';
import path from 'path';

interface ProblemData {
  id: number;
  turn: string;
  createdDate: string;
  description: string;
  sgfContent: string;
}

export function loadProblemFromDirectory(problemId: string): ProblemData | null {
  const problemDir = path.join(__dirname, '../../public/problems', problemId);
  
  try {
    // description.txt ã®èª­ã¿è¾¼ã¿
    const descriptionPath = path.join(problemDir, 'description.txt');
    const descriptionContent = fs.readFileSync(descriptionPath, 'utf-8');
    
    // SGFãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
    const sgfPath = path.join(problemDir, 'kifu.sgf');
    const sgfContent = fs.readFileSync(sgfPath, 'utf-8');
    
    // description.txt ã®ãƒ‘ãƒ¼ã‚¹
    const problemData = parseDescriptionFile(descriptionContent);
    
    return {
      ...problemData,
      sgfContent
    };
  } catch (error) {
    console.error(`Failed to load problem ${problemId}:`, error);
    return null;
  }
}

function parseDescriptionFile(content: string): Omit<ProblemData, 'sgfContent'> {
  const lines = content.trim().split('\n');
  const data: any = {};
  
  lines.forEach(line => {
    const [key, ...valueParts] = line.split(':');
    if (key && valueParts.length > 0) {
      data[key.trim()] = valueParts.join(':').trim();
    }
  });
  
  // å¿…é ˆé …ç›®ã®ãƒã‚§ãƒƒã‚¯
  if (!data.id || !data.turn || !data.created || !data.description) {
    throw new Error('å¿…é ˆé …ç›®ãŒä¸è¶³ã—ã¦ã„ã¾ã™: id, turn, created, description');
  }
  
  return {
    id: parseInt(data.id),
    turn: data.turn,
    createdDate: data.created,
    description: data.description,
    moves: data.moves ? parseInt(data.moves) : undefined
  };
}

// å…¨å•é¡Œã®ä¸€è¦§ã‚’å–å¾—
export function getAllProblems(): ProblemData[] {
  const problemsDir = path.join(__dirname, '../../public/problems');
  
  try {
    const problemDirs = fs.readdirSync(problemsDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => dirent.name);
    
    const problems: ProblemData[] = [];
    
    problemDirs.forEach(dirName => {
      const problemData = loadProblemFromDirectory(dirName);
      if (problemData) {
        problems.push(problemData);
      }
    });
    
    // ä½œæˆæ—¥æ™‚é †ã§ã‚½ãƒ¼ãƒˆï¼ˆæ–°ã—ã„é †ï¼‰
    return problems.sort((a, b) => 
      new Date(b.createdDate).getTime() - new Date(a.createdDate).getTime()
    );
  } catch (error) {
    console.error('Failed to load problems:', error);
    return [];
  }
}
```

### 8.11. ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å•é¡Œä¸€è¦§æ›´æ–°æ©Ÿèƒ½

**å®Ÿè£…æ–¹å¼:** ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ç›£è¦– + WebSocket

æ–°ã—ã„å•é¡ŒãŒ `public/problems/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«è¿½åŠ ã•ã‚ŒãŸéš›ã«ã€ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ã®å•é¡Œä¸€è¦§ã«ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§åæ˜ ã•ã‚Œã‚‹æ©Ÿèƒ½ã‚’å®Ÿè£…ã™ã‚‹ã€‚

**æŠ€è¡“æ§‹æˆ:**
- Node.js `chokidar` ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–
- Socket.io ã§WebSocketé€šä¿¡
- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°

**ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰å®Ÿè£…:**

```typescript
// server/utils/file-watcher.ts
import chokidar from 'chokidar';
import { Server as SocketIOServer } from 'socket.io';
import path from 'path';
import { loadProblemFromDirectory, getAllProblems } from './problem-loader';

export class ProblemWatcher {
  private io: SocketIOServer;
  private watcher: chokidar.FSWatcher;
  private problemsDir: string;

  constructor(io: SocketIOServer) {
    this.io = io;
    this.problemsDir = path.join(__dirname, '../../public/problems');
    this.initializeWatcher();
  }

  private initializeWatcher() {
    // problems ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å¤‰æ›´ã‚’ç›£è¦–
    this.watcher = chokidar.watch(this.problemsDir, {
      ignored: /node_modules/,
      persistent: true,
      depth: 2 // å•é¡Œãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¾ã§ç›£è¦–
    });

    // æ–°ã—ã„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒè¿½åŠ ã•ã‚ŒãŸå ´åˆ
    this.watcher.on('addDir', (dirPath) => {
      if (this.isProblemDirectory(dirPath)) {
        this.handleNewProblem(dirPath);
      }
    });

    // ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¿½åŠ ã•ã‚ŒãŸå ´åˆï¼ˆdescription.txt ã‚„ kifu.sgfï¼‰
    this.watcher.on('add', (filePath) => {
      if (this.isRelevantFile(filePath)) {
        const problemDir = path.dirname(filePath);
        this.handleProblemUpdate(problemDir);
      }
    });

    // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆ
    this.watcher.on('change', (filePath) => {
      if (this.isRelevantFile(filePath)) {
        const problemDir = path.dirname(filePath);
        this.handleProblemUpdate(problemDir);
      }
    });

    console.log('File watcher initialized for problems directory');
  }

  private isProblemDirectory(dirPath: string): boolean {
    const relativePath = path.relative(this.problemsDir, dirPath);
    // problems ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç›´ä¸‹ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã¤ã€æ•°å­—ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå
    return relativePath.split(path.sep).length === 1 && /^\d+$/.test(path.basename(dirPath));
  }

  private isRelevantFile(filePath: string): boolean {
    const fileName = path.basename(filePath);
    return fileName === 'description.txt' || fileName === 'kifu.sgf';
  }

  private async handleNewProblem(dirPath: string) {
    const problemId = path.basename(dirPath);
    console.log(`New problem detected: ${problemId}`);
    
    // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ã‚³ãƒ”ãƒ¼ãŒå®Œäº†ã™ã‚‹ã¾ã§ï¼‰
    setTimeout(() => {
      this.handleProblemUpdate(dirPath);
    }, 1000);
  }

  private async handleProblemUpdate(dirPath: string) {
    const problemId = path.basename(dirPath);
    
    try {
      // å•é¡Œãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
      const problemData = loadProblemFromDirectory(problemId);
      
      if (problemData) {
        console.log(`Problem updated: ${problemId}`);
        
        // å…¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«æ›´æ–°ã‚’é€šçŸ¥
        this.io.emit('problemUpdated', {
          type: 'update',
          problem: problemData
        });
        
        // å•é¡Œä¸€è¦§å…¨ä½“ã‚‚é€ä¿¡ï¼ˆæ–°è¦è¿½åŠ ã®å ´åˆï¼‰
        const allProblems = getAllProblems();
        this.io.emit('problemsListUpdated', allProblems);
      }
    } catch (error) {
      console.error(`Error loading problem ${problemId}:`, error);
    }
  }

  public destroy() {
    if (this.watcher) {
      this.watcher.close();
    }
  }
}
```

**Express + Socket.io ã‚µãƒ¼ãƒãƒ¼è¨­å®šï¼ˆæ›´æ–°ç‰ˆï¼‰:**

```typescript
// server/index.tsï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°å¯¾å¿œç‰ˆï¼‰
import express from 'express';
import { createServer } from 'http';
import { Server as SocketIOServer } from 'socket.io';
import cors from 'cors';
import path from 'path';
import apiRoutes from './routes/api';
import { ProblemWatcher } from './utils/file-watcher';
import { getAllProblems } from './utils/problem-loader';

const app = express();
const server = createServer(app);
const io = new SocketIOServer(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"]
  }
});

const port = process.env.PORT || 3000;

// ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// é™çš„ãƒ•ã‚¡ã‚¤ãƒ«é…ä¿¡
app.use(express.static(path.join(__dirname, '../public/dist')));
app.use('/problems', express.static(path.join(__dirname, '../public/problems')));
app.use('/ogp', express.static(path.join(__dirname, '../public/ogp')));

// API ãƒ«ãƒ¼ãƒˆ
app.use('/api', apiRoutes);

// WebSocketæ¥ç¶šå‡¦ç†
io.on('connection', (socket) => {
  console.log('Client connected:', socket.id);
  
  // æ¥ç¶šæ™‚ã«ç¾åœ¨ã®å•é¡Œä¸€è¦§ã‚’é€ä¿¡
  socket.emit('initialProblems', getAllProblems());
  
  socket.on('disconnect', () => {
    console.log('Client disconnected:', socket.id);
  });
});

// ãƒ•ã‚¡ã‚¤ãƒ«ç›£è¦–ã‚’é–‹å§‹
const problemWatcher = new ProblemWatcher(io);

// SPAç”¨ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '../public/dist/index.html'));
});

// ã‚µãƒ¼ãƒãƒ¼çµ‚äº†æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
process.on('SIGTERM', () => {
  problemWatcher.destroy();
  server.close();
});

server.listen(port, () => {
  console.log(`Server running on port ${port}`);
});
```

**ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰å®Ÿè£…:**

```typescript
// client/src/hooks/useRealTimeProblems.ts
import { useEffect, useState } from 'react';
import { io, Socket } from 'socket.io-client';

interface Problem {
  id: number;
  description: string;
  turn: string;
  createdDate: string;
  answerCount?: number;
}

export function useRealTimeProblems() {
  const [problems, setProblems] = useState<Problem[]>([]);
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    // Socket.ioæ¥ç¶š
    const newSocket = io();
    setSocket(newSocket);

    // æ¥ç¶šçŠ¶æ…‹ã®ç®¡ç†
    newSocket.on('connect', () => {
      console.log('Connected to server');
      setIsConnected(true);
    });

    newSocket.on('disconnect', () => {
      console.log('Disconnected from server');
      setIsConnected(false);
    });

    // åˆæœŸå•é¡Œä¸€è¦§å—ä¿¡
    newSocket.on('initialProblems', (initialProblems: Problem[]) => {
      console.log('Received initial problems:', initialProblems);
      setProblems(initialProblems);
    });

    // å•é¡Œä¸€è¦§æ›´æ–°å—ä¿¡
    newSocket.on('problemsListUpdated', (updatedProblems: Problem[]) => {
      console.log('Problems list updated:', updatedProblems);
      setProblems(updatedProblems);
    });

    // å€‹åˆ¥å•é¡Œæ›´æ–°å—ä¿¡
    newSocket.on('problemUpdated', (data: { type: string; problem: Problem }) => {
      console.log('Problem updated:', data);
      
      if (data.type === 'update') {
        setProblems(prev => {
          const existingIndex = prev.findIndex(p => p.id === data.problem.id);
          if (existingIndex >= 0) {
            // æ—¢å­˜å•é¡Œã®æ›´æ–°
            const updated = [...prev];
            updated[existingIndex] = data.problem;
            return updated;
          } else {
            // æ–°è¦å•é¡Œã®è¿½åŠ 
            return [data.problem, ...prev].sort((a, b) => 
              new Date(b.createdDate).getTime() - new Date(a.createdDate).getTime()
            );
          }
        });
      }
    });

    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    return () => {
      newSocket.close();
    };
  }, []);

  return {
    problems,
    isConnected,
    socket
  };
}
```

**ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ:**

```typescript
// client/src/pages/Home.tsx
import React from 'react';
import { useRealTimeProblems } from '../hooks/useRealTimeProblems';

export function Home() {
  const { problems, isConnected } = useRealTimeProblems();

  return (
    <div className="home-page">
      <header>
        <h1>ã„ã”ã‚‚ã‚“ - å›²ç¢ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆã‚µã‚¤ãƒˆ</h1>
        <div className="connection-status">
          {isConnected ? (
            <span className="connected">ğŸŸ¢ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ä¸­</span>
          ) : (
            <span className="disconnected">ğŸ”´ æ¥ç¶šä¸­...</span>
          )}
        </div>
      </header>
      
      <main>
        <div className="problems-list">
          {problems.length === 0 ? (
            <p>å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“</p>
          ) : (
            problems.map(problem => (
              <div key={problem.id} className="problem-card">
                <h3>å•é¡Œ {problem.id}</h3>
                <p>{problem.description}</p>
                <div className="problem-meta">
                  <span>æ‰‹ç•ª: {problem.turn === 'black' ? 'é»’ç•ª' : 'ç™½ç•ª'}</span>
                  <span>ä½œæˆæ—¥: {problem.createdDate}</span>
                  {problem.answerCount !== undefined && (
                    <span>å›ç­”æ•°: {problem.answerCount}</span>
                  )}
                </div>
                <a href={`/questionnaire/${problem.id}`} className="button">
                  å›ç­”ã™ã‚‹
                </a>
              </div>
            ))
          )}
        </div>
      </main>
    </div>
  );
}
```

### 8.12. APIå®Ÿè£…ã®æ›´æ–°ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å¯¾å¿œï¼‰

```typescript
// server/routes/api.ts ã«è¿½åŠ 
import { loadProblemFromDirectory, getAllProblems } from '../utils/problem-loader';

// SGFãƒ•ã‚¡ã‚¤ãƒ«å–å¾—
router.get('/sgf/:problemId', (req, res) => {
  try {
    const problemId = req.params.problemId;
    const problemData = loadProblemFromDirectory(problemId);
    
    if (!problemData) {
      return res.status(404).json({ error: 'Problem not found' });
    }
    
    res.setHeader('Content-Type', 'application/x-go-sgf');
    res.send(problemData.sgfContent);
  } catch (error) {
    console.error('Error getting SGF:', error);
    res.status(500).json({ error: 'Failed to get SGF' });
  }
});

// å•é¡Œä¸€è¦§å–å¾—ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹ + ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆï¼‰
router.get('/problems', async (req, res) => {
  try {
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰å•é¡Œä¸€è¦§ã‚’å–å¾—
    const fileProblems = getAllProblems();
    
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å›ç­”æ•°ã‚‚å«ã‚ã¦è¿”ã™
    const problemsWithCounts = await Promise.all(
      fileProblems.map(async (problem) => {
        const answerCount = await prisma.answer.count({
          where: {
            problemId: problem.id,
            isDeleted: false
          }
        });
        
        return {
          ...problem,
          answerCount
        };
      })
    );
    
    res.json(problemsWithCounts);
  } catch (error) {
    console.error('Error getting problems:', error);
    res.status(500).json({ error: 'Failed to get problems' });
  }
});
```

### 8.13. ä¾å­˜é–¢ä¿‚ã®æ›´æ–°ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ©Ÿèƒ½è¿½åŠ ï¼‰

```json
{
  "dependencies": {
    // ...existing dependencies...
    "socket.io": "^4.7.0",
    "socket.io-client": "^4.7.0", 
    "chokidar": "^3.5.0"
  },
  "devDependencies": {
    // ...existing dependencies...
    "@types/socket.io": "^3.0.0"
  }
}
```

### 8.14. é‹ç”¨ä¸Šã®æ³¨æ„ç‚¹

**ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°æ©Ÿèƒ½:**
- `public/problems/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«æ–°ã—ã„å•é¡Œã‚’é…ç½®ã™ã‚‹ã¨è‡ªå‹•ã§ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ã«åæ˜ 
- ãƒ•ã‚¡ã‚¤ãƒ«ã‚³ãƒ”ãƒ¼ä¸­ã®èª¤æ¤œçŸ¥ã‚’é¿ã‘ã‚‹ãŸã‚ã€1ç§’ã®é…å»¶å‡¦ç†ã‚’å®Ÿè£…
- WebSocketãŒåˆ©ç”¨ã§ããªã„ç’°å¢ƒã§ã¯ã€ãƒãƒ¼ãƒªãƒ³ã‚°æ–¹å¼ã¸ã®åˆ‡ã‚Šæ›¿ãˆã‚‚å¯èƒ½

**å•é¡Œé…ç½®æ‰‹é †:**
1. `public/problems/{å•é¡Œç•ªå·}/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆï¼ˆIDé‡è¤‡ãƒã‚§ãƒƒã‚¯å®Ÿæ–½ï¼‰
2. `kifu.sgf` ã¨ `description.txt`ï¼ˆUTF-8ï¼‰ã‚’é…ç½®
3. è‡ªå‹•çš„ã«OGPç”»åƒãŒç”Ÿæˆã•ã‚Œã‚‹ï¼ˆ1200x630pxï¼‰
4. è‡ªå‹•çš„ã«ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ã«åæ˜ ã•ã‚Œã‚‹

**ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°:**
- SGFãƒ•ã‚¡ã‚¤ãƒ«ãŒä¸æ­£ãªå ´åˆã¯ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’å‡ºåŠ›ã—ã€ãã®å•é¡Œã¯ã‚¹ã‚­ãƒƒãƒ—
- description.txtã®å¿…é ˆé …ç›®ãŒæ¬ ã‘ã¦ã„ã‚‹å ´åˆã‚‚ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’å‡ºåŠ›
- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼æ™‚ã®å†è©¦è¡Œå‡¦ç†ã¯å®Ÿè£…ã—ãªã„

**ãƒ‡ãƒ—ãƒ­ã‚¤æ–¹æ³•:**
- Gitã§ã‚¯ãƒ­ãƒ¼ãƒ³ã—ã¦å±•é–‹
- PM2/foreverãªã©ã®ãƒ—ãƒ­ã‚»ã‚¹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¯ä½¿ç”¨ã—ãªã„
- å˜ç´”ãª`node server/index.js`ã§èµ·å‹•
